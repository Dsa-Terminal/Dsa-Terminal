<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Reading_Data_Files">Reading Data Files</a></li>
<li><a href="#Reading_Unstructured_Text_Data">Reading Unstructured Text Data</a></li>
<li><a href="#Reading_Columnar_Data">Reading Columnar Data</a></li>
<li><a href="#Reading_Configuration_Files">Reading Configuration Files</a></li>
<li><a href="#Lexical_Scanning">Lexical Scanning</a></li>
<li><a href="#XML">XML</a></li>
</ul>


<h2>Topics</h2>
<ul>
  <li><a href="../topics/01-introduction.md.html">01-introduction.md</a></li>
  <li><a href="../topics/02-arrays.md.html">02-arrays.md</a></li>
  <li><a href="../topics/03-strings.md.html">03-strings.md</a></li>
  <li><a href="../topics/04-paths.md.html">04-paths.md</a></li>
  <li><a href="../topics/05-dates.md.html">05-dates.md</a></li>
  <li><strong>06-data.md</strong></li>
  <li><a href="../topics/07-functional.md.html">07-functional.md</a></li>
  <li><a href="../topics/08-additional.md.html">08-additional.md</a></li>
  <li><a href="../topics/09-discussion.md.html">09-discussion.md</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/pl.html">pl</a></li>
  <li><a href="../modules/pl.Date.html">pl.Date</a></li>
  <li><a href="../modules/pl.List.html">pl.List</a></li>
  <li><a href="../modules/pl.Map.html">pl.Map</a></li>
  <li><a href="../modules/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../modules/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../modules/pl.Set.html">pl.Set</a></li>
  <li><a href="../modules/pl.app.html">pl.app</a></li>
  <li><a href="../modules/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../modules/pl.class.html">pl.class</a></li>
  <li><a href="../modules/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../modules/pl.config.html">pl.config</a></li>
  <li><a href="../modules/pl.data.html">pl.data</a></li>
  <li><a href="../modules/pl.dir.html">pl.dir</a></li>
  <li><a href="../modules/pl.file.html">pl.file</a></li>
  <li><a href="../modules/pl.func.html">pl.func</a></li>
  <li><a href="../modules/pl.input.html">pl.input</a></li>
  <li><a href="../modules/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../modules/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../modules/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../modules/pl.operator.html">pl.operator</a></li>
  <li><a href="../modules/pl.path.html">pl.path</a></li>
  <li><a href="../modules/pl.permute.html">pl.permute</a></li>
  <li><a href="../modules/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../modules/pl.seq.html">pl.seq</a></li>
  <li><a href="../modules/pl.sip.html">pl.sip</a></li>
  <li><a href="../modules/pl.strict.html">pl.strict</a></li>
  <li><a href="../modules/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../modules/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../modules/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../modules/pl.template.html">pl.template</a></li>
  <li><a href="../modules/pl.test.html">pl.test</a></li>
  <li><a href="../modules/pl.text.html">pl.text</a></li>
  <li><a href="../modules/pl.utils.html">pl.utils</a></li>
  <li><a href="../modules/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Examples</h2>
<ul>
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Topic <code>06-data.md</code></h1>

    <h2>Data</h2>

<p><a name="Reading_Data_Files"></a></p>

<h3>Reading Data Files</h3>

<p>The first thing to consider is this: do you actually need to write a custom file reader? And if the answer is yes, the next question is: can you write the reader in as clear a way as possible? Correctness, Robustness, and Speed; pick the first two and the third can be sorted out later, <em>if necessary</em>.</p>

<p>A common sort of data file is the configuration file format commonly used on Unix systems. This format is often called a <em>property</em> file in the Java world.</p>

<pre>
 # Read timeout <span class="keyword">in</span> seconds
 read.timeout=<span class="number">10</span>

 # Write timeout <span class="keyword">in</span> seconds
 write.timeout=<span class="number">10</span>
</pre>


<p>Here is a simple Lua implementation:</p>

<pre>
 <span class="comment">-- property file parsing with Lua string patterns
</span> props = []
 <span class="keyword">for</span> line <span class="keyword">in</span> <span class="global">io</span>.lines() <span class="keyword">do</span>
     <span class="keyword">if</span> line:find(<span class="string">'#,1,true) ~= 1 and not line:find('</span>^%s*$<span class="string">') then
         local var,value = line:match('</span>([^=]+)=(.*)')
         props[var] = value
     <span class="keyword">end</span>
 <span class="keyword">end</span>
</pre>


<p>Very compact, but it suffers from a similar disease in equivalent Perl programs; it uses odd string patterns which are &lsquo;lexically noisy&rsquo;. Noisy code like this slows the casual reader down. (For an even more direct way of doing this, see the next section, &lsquo;Reading Configuration Files&rsquo;)</p>

<p>Another implementation, using the Penlight libraries:</p>

<pre>
 <span class="comment">-- property file parsing with extended string functions
</span> <span class="global">require</span> <span class="string">'pl'</span>
 stringx.import()
 props = []
 <span class="keyword">for</span> line <span class="keyword">in</span> <span class="global">io</span>.lines() <span class="keyword">do</span>
     <span class="keyword">if</span> <span class="keyword">not</span> line:startswith(<span class="string">'#'</span>) <span class="keyword">and</span> <span class="keyword">not</span> line:isspace() <span class="keyword">then</span>
         <span class="keyword">local</span> var,value = line:splitv(<span class="string">'='</span>)
         props[var] = value
     <span class="keyword">end</span>
 <span class="keyword">end</span>
</pre>


<p>This is more self-documenting; it is generally better to make the code express the <em>intention</em>, rather than having to scatter comments everywhere &ndash; comments are necessary, of course, but mostly to give the higher view of your intention that cannot be expressed in code. It is slightly slower, true, but in practice the speed of this script is determined by I/O, so further optimization is unnecessary.</p>

<p><a name="Reading_Unstructured_Text_Data"></a></p>

<h3>Reading Unstructured Text Data</h3>

<p>Text data is sometimes unstructured, for example a file containing words. The <a href="../modules/pl.input.html#">pl.input</a>  module has a number of functions which makes processing such files easier. For example, a script to count the number of words in standard input using <code>import.words</code>:</p>

<pre>
 <span class="comment">-- countwords.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="keyword">local</span> k = <span class="number">1</span>
 <span class="keyword">for</span> w <span class="keyword">in</span> input.words(<span class="global">io</span>.stdin) <span class="keyword">do</span>
     k = k + <span class="number">1</span>
 <span class="keyword">end</span>
 <span class="global">print</span>(<span class="string">'count'</span>,k)
</pre>


<p>Or this script to calculate the average of a set of numbers using <a href="../modules/pl.input.html#numbers">input.numbers</a> :</p>

<pre>
 <span class="comment">-- average.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="keyword">local</span> k = <span class="number">1</span>
 <span class="keyword">local</span> sum = <span class="number">0</span>
 <span class="keyword">for</span> n <span class="keyword">in</span> input.numbers(<span class="global">io</span>.stdin) <span class="keyword">do</span>
     sum = sum + n
     k = k + <span class="number">1</span>
 <span class="keyword">end</span>
 <span class="global">print</span>(<span class="string">'average'</span>,sum/k)
</pre>


<p>These scripts can be improved further by <em>eliminating loops</em> In the last case, there is a perfectly good function <a href="../modules/pl.seq.html#sum">seq.sum</a>  which can already take a sequence of numbers and calculate these numbers for us:</p>

<pre>
 <span class="comment">-- average2.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="keyword">local</span> total,n = seq.sum(input.numbers())
 <span class="global">print</span>(<span class="string">'average'</span>,total/n)
</pre>


<p>A further simplification here is that if <code>numbers</code> or <code>words</code> are not passed an argument, they will grab their input from standard input.  The first script can be rewritten:</p>

<pre>
 <span class="comment">-- countwords2.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="global">print</span>(<span class="string">'count'</span>,seq.count(input.words()))
</pre>


<p>A useful feature of a sequence generator like <code>numbers</code> is that it can read from a string source. Here is a script to calculate the sums of the numbers on each line in a file:</p>

<pre>
 <span class="comment">-- sums.lua
</span> <span class="keyword">for</span> line <span class="keyword">in</span> <span class="global">io</span>.lines() <span class="keyword">do</span>
     <span class="global">print</span>(seq.sum(input.numbers(line))
 <span class="keyword">end</span>
</pre>


<p><a name="Reading_Columnar_Data"></a></p>

<h3>Reading Columnar Data</h3>

<p>It is very common to find data in columnar form, either space or comma-separated, perhaps with an initial set of column headers. Here is a typical example:</p>

<pre>
 EventID    Magnitude    LocationX    LocationY    LocationZ
 <span class="number">981124001</span>    <span class="number">2.0</span>    <span class="number">18988.4</span>    <span class="number">10047.1</span>    <span class="number">4149.7</span>
 <span class="number">981125001</span>    <span class="number">0.8</span>    <span class="number">19104.0</span>    <span class="number">9970.4</span>    <span class="number">5088.7</span>
 <span class="number">981127003</span>    <span class="number">0.5</span>    <span class="number">19012.5</span>    <span class="number">9946.9</span>    <span class="number">3831.2</span>
 ...
</pre>


<p><a href="../modules/pl.input.html#fields">input.fields</a>  is designed to extract several columns, given some delimiter (default to whitespace).  Here is a script to calculate the average X location of all the events:</p>

<pre>
 <span class="comment">-- avg-x.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="global">io</span>.read() <span class="comment">-- skip the header line
</span> <span class="keyword">local</span> sum,count = seq.sum(input.fields {<span class="number">3</span>})
 <span class="global">print</span>(sum/count)
</pre>


<p><a href="../modules/pl.input.html#fields">input.fields</a>  is passed either a field count, or a list of column indices, starting at one as usual. So in this case we're only interested in column 3.  If you pass it a field count, then you get every field up to that count:</p>

<pre>
 <span class="keyword">for</span> id,mag,locX,locY,locZ <span class="keyword">in</span> input.fields (<span class="number">5</span>) <span class="keyword">do</span>
 ....
 <span class="keyword">end</span>
</pre>


<p><a href="../modules/pl.input.html#fields">input.fields</a>  by default tries to convert each field to a number. It will skip lines which clearly don&rsquo;t match the pattern, but will abort the script if there are any fields which cannot be converted to numbers.</p>

<p>The second parameter is a delimiter, by default spaces. &lsquo; &rsquo; is understood to mean &lsquo;any number of spaces&rsquo;, i.e. &lsquo;%s+&rsquo;. Any Lua string pattern can be used.</p>

<p>The third parameter is a <em>data source</em>, by default standard input (defined by <a href="../modules/pl.input.html#create_getter">input.create_getter</a> .) It assumes that the data source has a <code>read</code> method which brings in the next line, i.e. it is a &lsquo;file-like&rsquo; object. As a special case, a string will be split into its lines:</p>

<pre>
 &gt; <span class="keyword">for</span> x,y <span class="keyword">in</span> input.fields(<span class="number">2</span>,<span class="string">' '</span>,<span class="string">'10 20\n30 40\n'</span>) <span class="keyword">do</span> <span class="global">print</span>(x,y) <span class="keyword">end</span>
 <span class="number">10</span>      <span class="number">20</span>
 <span class="number">30</span>      <span class="number">40</span>
</pre>


<p>Note the default behaviour for bad fields, which is to show the offending line number:</p>

<pre>
 &gt; <span class="keyword">for</span> x,y <span class="keyword">in</span> input.fields(<span class="number">2</span>,<span class="string">' '</span>,<span class="string">'10 20\n30 40x\n'</span>) <span class="keyword">do</span> <span class="global">print</span>(x,y) <span class="keyword">end</span>
 <span class="number">10</span>      <span class="number">20</span>
 line <span class="number">2</span>: cannot convert <span class="string">'40x'</span> to number
</pre>


<p>This behaviour of <a href="../modules/pl.input.html#fields">input.fields</a>  is appropriate for a script which you want to fail immediately with an appropriate <em>user</em> error message if conversion fails. The fourth optional parameter is an options table: <code>{no_fail=true}</code> means that conversion is attempted but if it fails it just returns the string, rather as AWK would operate. You are then responsible for checking the type of the returned field. <code>{no_convert=true}</code> switches off conversion altogether and all fields are returned as strings.</p>

<p>Sometimes it is useful to bring a whole dataset into memory, for operations such as extracting columns. Penlight provides a flexible reader specifically for reading this kind of data, using the <a href="../modules/pl.data.html#">data</a>  module. Given a file looking like this:</p>

<pre>
 x,y
 <span class="number">10</span>,<span class="number">20</span>
 <span class="number">2</span>,<span class="number">5</span>
 <span class="number">40</span>,<span class="number">50</span>
</pre>


<p>Then <a href="../modules/pl.data.html#read">data.read</a>  will create a table like this, with each row represented by a sublist:</p>

<pre>
 &gt; t = data.read <span class="string">'test.txt'</span>
 &gt; pretty.dump(t)
 {{<span class="number">10</span>,<span class="number">20</span>},{<span class="number">2</span>,<span class="number">5</span>},{<span class="number">40</span>,<span class="number">50</span>},fieldnames={<span class="string">'x'</span>,<span class="string">'y'</span>},delim=<span class="string">','</span>}
</pre>


<p>You can now analyze this returned table using the supplied methods. For instance, the method <code>column_by_name</code> returns a table of all the values of that column.</p>

<pre>
 <span class="comment">-- testdata.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 d = data.read(<span class="string">'fev.txt'</span>)
 <span class="keyword">for</span> _,name <span class="keyword">in</span> <span class="global">ipairs</span>(d.fieldnames) <span class="keyword">do</span>
     <span class="keyword">local</span> col = d:column_by_name(name)
     <span class="keyword">if</span> <span class="global">type</span>(col[<span class="number">1</span>]) == <span class="string">'number'</span> <span class="keyword">then</span>
         <span class="keyword">local</span> total,n = seq.sum(col)
         utils.printf(<span class="string">"Average for %s is %f\n"</span>,name,total/n)
     <span class="keyword">end</span>
 <span class="keyword">end</span>
</pre>


<p><a href="../modules/pl.data.html#read">data.read</a>  tries to be clever when given data; by default it expects a first line of column names, unless any of them are numbers. It tries to deduce the column delimiter by looking at the first line. Sometimes it guesses wrong; these things can be specified explicitly. The second optional parameter is an options table: can override <code>delim</code> (a string pattern), <code>fieldnames</code> (a list or comma-separated string), specify <code>no_convert</code> (default is to convert), numfields (indices of columns known to be numbers, as a list) and <code>thousands_dot</code> (when the thousands separator in Excel CSV is &lsquo;.&rsquo;)</p>

<p>A very powerful feature is a way to execute SQL-like queries on such data:</p>

<pre>
 <span class="comment">-- queries on tabular data
</span> <span class="global">require</span> <span class="string">'pl'</span>
 <span class="keyword">local</span> d = data.read(<span class="string">'xyz.txt'</span>)
 <span class="keyword">local</span> q = d:<span class="global">select</span>(<span class="string">'x,y,z where x &gt; 3 and z &lt; 2 sort by y'</span>)
 <span class="keyword">for</span> x,y,z <span class="keyword">in</span> q <span class="keyword">do</span>
     <span class="global">print</span>(x,y,z)
 <span class="keyword">end</span>
</pre>


<p>Please note that the format of queries is restricted to the following syntax:</p>

<pre>
 FIELDLIST [ <span class="string">'where'</span> CONDITION ] [ <span class="string">'sort by'</span> FIELD [asc|desc]]
</pre>


<p>Any valid Lua code can appear in <code>CONDITION</code>; remember it is <em>not</em> SQL and you have to use <code>==</code> (this warning comes from experience.)</p>

<p>For this to work, <em>field names must be Lua identifiers</em>. So <a href="../modules/pl.data.html#read">read</a>  will massage fieldnames so that all non-alphanumeric chars are replaced with underscores.</p>

<p><a href="../modules/pl.data.html#read">read</a>  can handle standard CSV files fine, although doesn&rsquo;t try to be a full-blown CSV parser. Spreadsheet programs are not always the best tool to process such data, strange as this might seem to some people. This is a toy CSV file; to appreciate the problem, imagine thousands of rows and dozens of columns like this:</p>

<pre>
 Department Name,Employee ID,Project,Hours Booked
 sales,<span class="number">1231</span>,overhead,<span class="number">4</span>
 sales,<span class="number">1255</span>,overhead,<span class="number">3</span>
 engineering,<span class="number">1501</span>,development,<span class="number">5</span>
 engineering,<span class="number">1501</span>,maintenance,<span class="number">3</span>
 engineering,<span class="number">1433</span>,maintenance,<span class="number">10</span>
</pre>


<p>The task is to reduce the dataset to a relevant set of rows and columns, perhaps do some processing on row data, and write the result out to a new CSV file. The <code>write_row</code> method uses the delimiter to write the row to a file; <code>Data.select_row</code> is like <code>Data.select</code>, except it iterates over <em>rows</em>, not fields; this is necessary if we are dealing with a lot of columns!</p>

<pre>
 names = {[<span class="number">1501</span>]=<span class="string">'don'</span>,[<span class="number">1433</span>]=<span class="string">'dilbert'</span>}
 keepcols = {<span class="string">'Employee_ID'</span>,<span class="string">'Hours_Booked'</span>}
 t:write_row (outf,{<span class="string">'Employee'</span>,<span class="string">'Hours_Booked'</span>})
 q = t:select_row {
     fields=keepcols,
     where=<span class="keyword">function</span>(row) <span class="keyword">return</span> row[<span class="number">1</span>]==<span class="string">'engineering'</span> <span class="keyword">end</span>
 }
 <span class="keyword">for</span> row <span class="keyword">in</span> q <span class="keyword">do</span>
     row[<span class="number">1</span>] = names[row[<span class="number">1</span>]]
     t:write_row(outf,row)
 <span class="keyword">end</span>
</pre>


<p><code>Data.select_row</code> and <code>Data.select</code> can be passed a table specifying the query; a list of field names, a function defining the condition and an optional parameter <code>sort_by</code>. It isn&rsquo;t really necessary here, but if we had a more complicated row condition (such as belonging to a specified set) then it is not generally possible to express such a condition as a query string, without resorting to hackery such as global variables.</p>

<p>Data does not have to come from files, nor does it necessarily come from the lab or the accounts department. On Linux, <code>ps aux</code> gives you a full listing of all processes running on your machine. It is straightforward to feed the output of this command into <a href="../modules/pl.data.html#read">data.read</a>  and perform useful queries on it. Notice that non-identifier characters like &lsquo;%&rsquo; get converted into underscores:</p>

<pre>
 <span class="global">require</span> <span class="string">'pl'</span>
 f = <span class="global">io</span>.popen <span class="string">'ps aux'</span>
 s = data.read (f,{last_field_collect=<span class="keyword">true</span>})
 f:close()
 <span class="global">print</span>(s.fieldnames)
 <span class="global">print</span>(s:column_by_name <span class="string">'USER'</span>)
 qs = <span class="string">'COMMAND,_MEM where _MEM &gt; 5 and USER=="steve"'</span>
 <span class="keyword">for</span> name,mem <span class="keyword">in</span> s:<span class="global">select</span>(qs) <span class="keyword">do</span>
     <span class="global">print</span>(mem,name)
 <span class="keyword">end</span>
</pre>


<p>I've always been an admirer of the AWK programming language; with <a href="../modules/pl.data.html#filter">filter</a>  you can get Lua programs which are just as compact:</p>

<pre>
 <span class="comment">-- printxy.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>
 data.filter <span class="string">'x,y where x &gt; 3'</span>
</pre>


<p>It is common enough to have data files without headers of field names. <a href="../modules/pl.data.html#read">data.read</a>  makes a special exception for such files if all fields are numeric. Since there are no column names to use in query expressions, you can use AWK-like column indexes, e.g. &lsquo;$1,$2 where $1 > 3&rsquo;.  I have a little executable script on my system called <code>lf</code> which looks like this:</p>

<pre>
 #!/usr/bin/env lua
 <span class="global">require</span> <span class="string">'pl.data'</span>.filter(arg[<span class="number">1</span>])
</pre>


<p>And it can be used generally as a filter command to extract columns from data. (The column specifications may be expressions or even constants.)</p>

<pre>
 $ lf <span class="string">'$1,$5/10'</span> &lt; test.dat
</pre>


<p>(As with AWK, please note the single-quotes used in this command; this prevents the shell trying to expand the column indexes. If you are on Windows, then you are fine, but it is still necessary to quote the expression in double-quotes so it is passed as one argument to your batch file.)</p>

<p>As a tutorial resource, have a look at <a href="../examples/test-data.lua.html#">test-data.lua</a>  in the PL tests directory for other examples of use, plus comments.</p>

<p>The data returned by <a href="../modules/pl.data.html#read">read</a>  or constructed by <code>Data.copy_select</code> from a query is basically just an array of rows: <code>{{1,2},{3,4}}</code>. So you may use <a href="../modules/pl.data.html#read">read</a>  to pull in any array-like dataset, and process with any function that expects such a implementation. In particular, the functions in <a href="../modules/pl.array2d.html#">array2d</a>  will work fine with this data. In fact, these functions are available as methods; e.g. <a href="../modules/pl.array2d.html#flatten">array2d.flatten</a>  can be called directly like so to give us a one-dimensional list:</p>

<pre>
 v = data.read(<span class="string">'dat.txt'</span>):flatten()
</pre>


<p>The data is also in exactly the right shape to be treated as matrices by <a href="http://lua-users.org/wiki/LuaMatrix">LuaMatrix</a>:</p>

<pre>
 &gt; matrix = <span class="global">require</span> <span class="string">'matrix'</span>
 &gt; m = matrix(data.read <span class="string">'mat.txt'</span>)
 &gt; = m
 <span class="number">1</span>       <span class="number">0.2</span>     <span class="number">0.3</span>
 <span class="number">0.2</span>     <span class="number">1</span>       <span class="number">0.1</span>
 <span class="number">0.1</span>     <span class="number">0.2</span>     <span class="number">1</span>
 &gt; = m^<span class="number">2</span>  <span class="comment">-- same as m*m
</span> <span class="number">1.07</span>    <span class="number">0.46</span>    <span class="number">0.62</span>
 <span class="number">0.41</span>    <span class="number">1.06</span>    <span class="number">0.26</span>
 <span class="number">0.24</span>    <span class="number">0.42</span>    <span class="number">1.05</span>
</pre>


<p><a href="../modules/pl.data.html#write">write</a>  will write matrices back to files for you.</p>

<p>Finally, for the curious, the global variable <code>_DEBUG</code> can be used to print out the actual iterator function which a query generates and dynamically compiles. By using code generation, we can get pretty much optimal performance out of arbitrary queries.</p>

<pre>
 &gt; lua -lpl -e <span class="string">"_DEBUG=true"</span> -e <span class="string">"data.filter 'x,y where x &gt; 4 sort by x'"</span> &lt; test.txt
 <span class="keyword">return</span> <span class="keyword">function</span> (t)
         <span class="keyword">local</span> i = <span class="number">0</span>
         <span class="keyword">local</span> v
         <span class="keyword">local</span> ls = {}
         <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="global">ipairs</span>(t) <span class="keyword">do</span>
             <span class="keyword">if</span> v[<span class="number">1</span>] &gt; <span class="number">4</span>  <span class="keyword">then</span>
                     ls[#ls+<span class="number">1</span>] = v
             <span class="keyword">end</span>
         <span class="keyword">end</span>
         <span class="global">table</span>.sort(ls,<span class="keyword">function</span>(v1,v2)
             <span class="keyword">return</span> v1[<span class="number">1</span>] &lt; v2[<span class="number">1</span>]
         <span class="keyword">end</span>)
         <span class="keyword">local</span> n = #ls
         <span class="keyword">return</span> <span class="keyword">function</span>()
             i = i + <span class="number">1</span>
             v = ls[i]
             <span class="keyword">if</span> i &gt; n <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>
             <span class="keyword">return</span> v[<span class="number">1</span>],v[<span class="number">2</span>]
         <span class="keyword">end</span>
 <span class="keyword">end</span>

 <span class="number">10</span>,<span class="number">20</span>
 <span class="number">40</span>,<span class="number">50</span>
</pre>


<p><a name="Reading_Configuration_Files"></a></p>

<h3>Reading Configuration Files</h3>

<p>The <a href="../modules/pl.config.html#">config</a>  module provides a simple way to convert several kinds of configuration files into a Lua table. Consider the simple example:</p>

<pre>
 # test.config
 # Read timeout <span class="keyword">in</span> seconds
 read.timeout=<span class="number">10</span>

 # Write timeout <span class="keyword">in</span> seconds
 write.timeout=<span class="number">5</span>

 #acceptable ports
 ports = <span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>
</pre>


<p>This can be easily brought in using <a href="../modules/pl.config.html#read">config.read</a>  and the result shown using <a href="../modules/pl.pretty.html#write">pretty.write</a> :</p>

<pre>
 <span class="comment">-- readconfig.lua
</span> <span class="keyword">local</span> config = <span class="global">require</span> <span class="string">'pl.config'</span>
 <span class="keyword">local</span> pretty= <span class="global">require</span> <span class="string">'pl.pretty'</span>

 <span class="keyword">local</span> t = config.read(arg[<span class="number">1</span>])
 <span class="global">print</span>(pretty.write(t))
</pre>


<p>and the output of <code>lua readconfig.lua test.config</code> is:</p>

<pre>
 {
   ports = {
     <span class="number">1002</span>,
     <span class="number">1003</span>,
     <span class="number">1004</span>
   },
   write_timeout = <span class="number">5</span>,
   read_timeout = <span class="number">10</span>
 }
</pre>


<p>That is, <a href="../modules/pl.config.html#read">config.read</a>  will bring in all key/value pairs, ignore # comments, and ensure that the key names are proper Lua identifiers by replacing non-identifier characters with &lsquo;_&rsquo;. If the values are numbers, then they will be converted. (So the value of <code>t.write_timeout</code> is the number 5). In addition, any values which are separated by commas will be converted likewise into an array.</p>

<p>Any line can be continued with a backslash. So this will all be considered one line:</p>

<pre>
 names=one,two,three, \
 four,five,six,seven, \
 eight,nine,ten
</pre>


<p>Windows-style INI files are also supported. The section structure of INI files translates naturally to nested tables in Lua:</p>

<pre>
 ; test.ini
 [timeouts]
 read=<span class="number">10</span> ; Read timeout <span class="keyword">in</span> seconds
 write=<span class="number">5</span> ; Write timeout <span class="keyword">in</span> seconds
 [portinfo]
 ports = <span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>
</pre>


<p> The output is:</p>

<pre>
 {
   portinfo = {
     ports = {
       <span class="number">1002</span>,
       <span class="number">1003</span>,
       <span class="number">1004</span>
     }
   },
   timeouts = {
     write = <span class="number">5</span>,
     read = <span class="number">10</span>
   }
 }
</pre>


<p>You can now refer to the write timeout as <code>t.timeouts.write</code>.</p>

<p>As a final example of the flexibility of <a href="../modules/pl.config.html#read">config.read</a> , if passed this simple comma-delimited file</p>

<pre>
 one,two,three
 <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>
 <span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>
 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>
</pre>


<p>it will produce the following table:</p>

<pre>
 {
   { <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span> },
   { <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> },
   { <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>  },
   { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }
 }
</pre>


<p><a href="../modules/pl.config.html#read">config.read</a>  isn&rsquo;t designed to read all CSV files in general, but intended to support some Unix configuration files not structured as key-value pairs, such as &lsquo;/etc/passwd&rsquo;.</p>

<p>This function is intended to be a Swiss Army Knife of configuration readers, but it does have to make assumptions, and you may not like them. So there is an optional extra parameter which allows some control, which is table that may have the following fields:</p>

<pre>
 {
    variablilize = <span class="keyword">true</span>,
    convert_numbers = <span class="keyword">true</span>,
    trim_space = <span class="keyword">true</span>,
    list_delim = <span class="string">','</span>
 }
</pre>


<p><code>variablilize</code> is the option that converted <code>write.timeout</code> in the first example to the valid Lua identifier <code>write_timeout</code>.  If <code>convert_numbers</code> is true, then an attempt is made to convert any string that starts like a number. <code>trim_space</code> ensures that there is no starting or trailing whitespace with values, and <code>list_delim</code> is the character that will be used to decide whether to split a value up into a list (it may be a Lua string pattern such as &lsquo;%s+&rsquo;.)</p>

<p>For instance, the password file in Unix is colon-delimited:</p>

<pre>
 t = config.read(<span class="string">'/etc/passwd'</span>,{list_delim=<span class="string">':'</span>})
</pre>


<p>This produces the following output on my system (only last two lines shown):</p>

<pre>
 {
   ...
   {
     <span class="string">"user"</span>,
     <span class="string">"x"</span>,
     <span class="string">"1000"</span>,
     <span class="string">"1000"</span>,
     <span class="string">"user,,,"</span>,
     <span class="string">"/home/user"</span>,
     <span class="string">"/bin/bash"</span>
   },
   {
     <span class="string">"sdonovan"</span>,
     <span class="string">"x"</span>,
     <span class="string">"1001"</span>,
     <span class="string">"1001"</span>,
     <span class="string">"steve donovan,28,,"</span>,
     <span class="string">"/home/sdonovan"</span>,
     <span class="string">"/bin/bash"</span>
   }
 }
</pre>


<p>You can get this into a more sensible format, where the usernames are the keys, with:</p>

<pre>
 t = tablex.pairmap(<span class="keyword">function</span>(k,v) <span class="keyword">return</span> v,v[<span class="number">1</span>] <span class="keyword">end</span>,t)
</pre>


<p>and you get:</p>

<pre>
 { ...
   sdonovan = {
     <span class="string">"sdonovan"</span>,
     <span class="string">"x"</span>,
     <span class="string">"1001"</span>,
     <span class="string">"1001"</span>,
     <span class="string">"steve donovan,28,,"</span>,
     <span class="string">"/home/sdonovan"</span>,
     <span class="string">"/bin/bash"</span>
   }
 ...
 }
</pre>


<p><a id="lexer"/></p>

<p><a name="Lexical_Scanning"></a></p>

<h3>Lexical Scanning</h3>

<p>Although Lua&rsquo;s string pattern matching is very powerful, there are times when something more powerful is needed.  <a href="../modules/pl.lexer.html#scan">pl.lexer.scan</a>  provides lexical scanners which <em>tokenizes</em> a string, classifying tokens into numbers, strings, etc.</p>

<pre>
 &gt; lua -lpl
 Lua <span class="number">5.1</span>.<span class="number">4</span>  Copyright (C) <span class="number">1994</span>-<span class="number">2008</span> Lua.org, PUC-Rio
 &gt; tok = lexer.scan <span class="string">'alpha = sin(1.5)'</span>
 &gt; = tok()
 iden    alpha
 &gt; = tok()
 =       =
 &gt; = tok()
 iden    sin
 &gt; = tok()
 (       (
 &gt; = tok()
 number  <span class="number">1.5</span>
 &gt; = tok()
 )       )
 &gt; = tok()
 (<span class="keyword">nil</span>)
</pre>


<p>The scanner is a function, which is repeatedly called and returns the <em>type</em> and <em>value</em> of the token.  Recognized basic types are &lsquo;iden&rsquo;,&lsquo;string&rsquo;,&lsquo;number&rsquo;, and &lsquo;space&rsquo;. and everything else is represented by itself. Note that by default the scanner will skip any &lsquo;space&rsquo; tokens.</p>

<p>&lsquo;comment&rsquo; and &lsquo;keyword&rsquo; aren&rsquo;t applicable to the plain scanner, which is not language-specific, but a scanner which understands Lua is available. It recognizes the Lua keywords, and understands both short and long comments and strings.</p>

<pre>
 &gt; <span class="keyword">for</span> t,v <span class="keyword">in</span> lexer.lua <span class="string">'for i=1,n do'</span> <span class="keyword">do</span> <span class="global">print</span>(t,v) <span class="keyword">end</span>
 keyword <span class="keyword">for</span>
 iden    i
 =       =
 number  <span class="number">1</span>
 ,       ,
 iden    n
 keyword <span class="keyword">do</span>
</pre>


<p>A lexical scanner is useful where you have highly-structured data which is not nicely delimited by newlines. For example, here is a snippet of a in-house file format which it was my task to maintain:</p>

<pre>
 points    (<span class="number">818344.1</span>,-<span class="number">20389.7</span>,-<span class="number">0.1</span>),(<span class="number">818337.9</span>,-<span class="number">20389.3</span>,-<span class="number">0.1</span>),(<span class="number">818332.5</span>,-<span class="number">20387.8</span>,-<span class="number">0.1</span>)
     ,(<span class="number">818327.4</span>,-<span class="number">20388</span>,-<span class="number">0.1</span>),(<span class="number">818322</span>,-<span class="number">20387.7</span>,-<span class="number">0.1</span>),(<span class="number">818316.3</span>,-<span class="number">20388.6</span>,-<span class="number">0.1</span>)
     ,(<span class="number">818309.7</span>,-<span class="number">20389.4</span>,-<span class="number">0.1</span>),(<span class="number">818303.5</span>,-<span class="number">20390.6</span>,-<span class="number">0.1</span>),(<span class="number">818295.8</span>,-<span class="number">20388.3</span>,-<span class="number">0.1</span>)
     ,(<span class="number">818290.5</span>,-<span class="number">20386.9</span>,-<span class="number">0.1</span>),(<span class="number">818285.2</span>,-<span class="number">20386.1</span>,-<span class="number">0.1</span>),(<span class="number">818279.3</span>,-<span class="number">20383.6</span>,-<span class="number">0.1</span>)
     ,(<span class="number">818274</span>,-<span class="number">20381.2</span>,-<span class="number">0.1</span>),(<span class="number">818274</span>,-<span class="number">20380.7</span>,-<span class="number">0.1</span>);
</pre>


<p>Here is code to extract the points using <a href="../modules/pl.lexer.html#">pl.lexer</a> :</p>

<pre>
 <span class="comment">-- assume 's' contains the text above...
</span> <span class="keyword">local</span> lexer = <span class="global">require</span> <span class="string">'pl.lexer'</span>
 <span class="keyword">local</span> expecting = lexer.expecting
 <span class="keyword">local</span> append = <span class="global">table</span>.insert

 <span class="keyword">local</span> tok = lexer.scan(s)

 <span class="keyword">local</span> points = {}
 <span class="keyword">local</span> t,v = tok() <span class="comment">-- should be 'iden','points'
</span>
 <span class="keyword">while</span> t ~= <span class="string">';'</span> <span class="keyword">do</span>
     c = {}
     expecting(tok,<span class="string">'('</span>)
     c.x = expecting(tok,<span class="string">'number'</span>)
     expecting(tok,<span class="string">','</span>)
     c.y = expecting(tok,<span class="string">'number'</span>)
     expecting(tok,<span class="string">','</span>)
     c.z = expecting(tok,<span class="string">'number'</span>)
     expecting(tok,<span class="string">')'</span>)
     t,v = tok()  <span class="comment">-- either ',' or ';'
</span>     append(points,c)
 <span class="keyword">end</span>
</pre>


<p>The <code>expecting</code> function grabs the next token and if the type doesn&rsquo;t match, it throws an error. (<a href="../modules/pl.lexer.html#">pl.lexer</a> , unlike other PL libraries, raises errors if something goes wrong, so you should wrap your code in <a href="http://www.lua.org/manual/5.1/manual.html#pdf-pcall">pcall</a>  to catch the error gracefully.)</p>

<p>The scanners all have a second optional argument, which is a table which controls whether you want to exclude spaces and/or comments. The default for <a href="../modules/pl.lexer.html#lua">lexer.lua</a>  is <code>{space=true,comments=true}</code>.  There is a third optional argument which determines how string and number tokens are to be processsed.</p>

<p>The ultimate highly-structured data is of course, program source. Here is a snippet from &lsquo;text-lexer.lua&rsquo;:</p>

<pre>
 <span class="global">require</span> <span class="string">'pl'</span>

 lines = <span class="string">[[
 for k,v in pairs(t) do
     if type(k) == 'number' then
         print(v) -- array-like case
     else
         print(k,v)
     end
 end
 ]]</span>

 ls = List()
 <span class="keyword">for</span> tp,val <span class="keyword">in</span> lexer.lua(lines,{space=<span class="keyword">true</span>,comments=<span class="keyword">true</span>}) <span class="keyword">do</span>
     <span class="global">assert</span>(tp ~= <span class="string">'space'</span> <span class="keyword">and</span> tp ~= <span class="string">'comment'</span>)
     <span class="keyword">if</span> tp == <span class="string">'keyword'</span> <span class="keyword">then</span> ls:append(val) <span class="keyword">end</span>
 <span class="keyword">end</span>
 test.asserteq(ls,List{<span class="string">'for'</span>,<span class="string">'in'</span>,<span class="string">'do'</span>,<span class="string">'if'</span>,<span class="string">'then'</span>,<span class="string">'else'</span>,<span class="string">'end'</span>,<span class="string">'end'</span>})
</pre>


<p>Here is a useful little utility that identifies all common global variables found in a lua module:</p>

<pre>
 <span class="comment">-- testglobal.lua
</span> <span class="global">require</span> <span class="string">'pl'</span>

 <span class="keyword">local</span> txt,err = utils.readfile(arg[<span class="number">1</span>])
 <span class="keyword">if</span> <span class="keyword">not</span> txt <span class="keyword">then</span> <span class="keyword">return</span> <span class="global">print</span>(err) <span class="keyword">end</span>

 <span class="keyword">local</span> globals = List()
 <span class="keyword">for</span> t,v <span class="keyword">in</span> lexer.lua(txt) <span class="keyword">do</span>
     <span class="keyword">if</span> t == <span class="string">'iden'</span> <span class="keyword">and</span> _G[v] <span class="keyword">then</span>
         globals:append(v)
     <span class="keyword">end</span>
 <span class="keyword">end</span>
 pretty.dump(seq.count_map(globals))
</pre>


<p>Rather then dumping the whole list, with its duplicates, we pass it through <a href="../modules/pl.seq.html#count_map">seq.count_map</a>  which turns the list into a table where the keys are the values, and the associated values are the number of times those values occur in the sequence. Typical output looks like this:</p>

<pre>
 {
   <span class="global">type</span> = <span class="number">2</span>,
   <span class="global">pairs</span> = <span class="number">2</span>,
   <span class="global">table</span> = <span class="number">2</span>,
   <span class="global">print</span> = <span class="number">3</span>,
   <span class="global">tostring</span> = <span class="number">2</span>,
   <span class="global">require</span> = <span class="number">1</span>,
   <span class="global">ipairs</span> = <span class="number">4</span>
 }
</pre>


<p>You could further pass this through <a href="../modules/pl.tablex.html#keys">tablex.keys</a>  to get a unique list of symbols. This can be useful when writing &lsquo;strict&rsquo; Lua modules, where all global symbols must be defined as locals at the top of the file.</p>

<p>For a more detailed use of <a href="../modules/pl.lexer.html#scan">lexer.scan</a> , please look at <a href="../examples/testxml.lua.html#">testxml.lua</a>  in the examples directory.</p>

<p><a name="XML"></a></p>

<h3>XML</h3>

<p>New in the 0.9.7 release is some support for XML. This is a large topic, and Penlight does not provide a full XML stack, which is properly the task of a more specialized library.</p>

<h4>Parsing and Pretty-Printing</h4>

<p>The semi-standard XML parser in the Lua universe is <a href="">lua-expat</a>. In particular, it has a function called <code>lxp.lom.parse</code> which will parse XML into the Lua Object Model (LOM) format. However, it does not provide a way to convert this data back into XML text.  <a href="../modules/pl.xml.html#parse">xml.parse</a>  will use this function, <em>if</em> <code>lua-expat</code> is available, and otherwise switches back to a pure Lua parser originally written by Roberto Ierusalimschy.</p>

<p>The resulting document object knows how to render itself as a string, which is useful for debugging:</p>

<pre>
 &gt; d = xml.parse <span class="string">"&lt;nodes&gt;&lt;node id='1'&gt;alice&lt;/node&gt;&lt;/nodes&gt;"</span>
 &gt; = d
 &lt;nodes&gt;&lt;node id=<span class="string">'1'</span>&gt;alice&lt;/node&gt;&lt;/nodes&gt;
 &gt; pretty.dump (d)
 {
   {
     <span class="string">"alice"</span>,
     attr = {
       <span class="string">"id"</span>,
       id = <span class="string">"1"</span>
     },
     tag = <span class="string">"node"</span>
   },
   attr = {
   },
   tag = <span class="string">"nodes"</span>
 }
</pre>


<p>Looking at the actual shape of the data reveals the structure of LOM:</p>

<ul>
<li>every element has a <code>tag</code> field with its name</li>
<li>plus a <code>attr</code> field which is a table containing the attributes as fields, and also as an array. It is always present.</li>
<li>the children of the element are the array part of the element, so <code>d[1]</code> is the first child of <code>d</code>, etc.</li>
</ul>


<p>It could be argued that having attributes also as the array part of <code>attr</code> is not essential (you generally cannot depend on attribute order in XML) but that&rsquo;s how it goes with this standard.</p>

<p><code>lua-expat</code> is another <em>soft dependency</em> of Penlight; generally, the fallback parser is good enough for straightforward XML as is commonly found in configuration files, etc. <code>doc.basic_parse</code> is not intended to be a proper conforming parser (it&rsquo;s only sixty lines) but it handles simple kinds of documents that do not have comments or DTD directives. It is intelligent enough to ignore the <code>&lt;?xml</code> directive and that is about it.</p>

<p>You can get pretty-printing by explicitly calling <a href="../modules/pl.xml.html#tostring">xml.tostring</a>  and passing it the initial indent and the per-element indent:</p>

<pre>
 &gt; = xml.<span class="global">tostring</span>(d,<span class="string">''</span>,<span class="string">'  '</span>)

 &lt;nodes&gt;
   &lt;node id=<span class="string">'1'</span>&gt;alice&lt;/node&gt;
 &lt;/nodes&gt;
</pre>


<p>There is a fourth argument which is the <em>attribute indent</em>:</p>

<pre>
 &gt; a = xml.parse <span class="string">"&lt;frodo name='baggins' age='50' type='hobbit'/&gt;"</span>
 &gt; = xml.<span class="global">tostring</span>(a,<span class="string">''</span>,<span class="string">'  '</span>,<span class="string">'  '</span>)

 &lt;frodo
   <span class="global">type</span>=<span class="string">'hobbit'</span>
   name=<span class="string">'baggins'</span>
   age=<span class="string">'50'</span>
 /&gt;
</pre>


<h4>Parsing and Working with Configuration Files</h4>

<p>It&rsquo;s common to find configurations expressed with XML these days. It&rsquo;s straightforward to &lsquo;walk&rsquo; the LOM data and extract the data in the form you want:</p>

<pre>
 <span class="global">require</span> <span class="string">'pl'</span>

 <span class="keyword">local</span> config = <span class="string">[[
 &lt;config&gt;
     &lt;alpha&gt;1.3&lt;/alpha&gt;
     &lt;beta&gt;10&lt;/beta&gt;
     &lt;name&gt;bozo&lt;/name&gt;
 &lt;/config&gt;
 ]]</span>
 <span class="keyword">local</span> d,err = xml.parse(config)

 <span class="keyword">local</span> t = {}
 <span class="keyword">for</span> item <span class="keyword">in</span> d:childtags() <span class="keyword">do</span>
     t[item.tag] = item[<span class="number">1</span>]
 <span class="keyword">end</span>

 pretty.dump(t)
 <span class="comment">---&gt;
</span> {
   beta = <span class="string">"10"</span>,
   alpha = <span class="string">"1.3"</span>,
   name = <span class="string">"bozo"</span>
 }
</pre>


<p>The only gotcha is that here we must use the <code>Doc:childtags</code> method, which will skip over any text elements.</p>

<p>A more involved example is this excerpt from <code>serviceproviders.xml</code>, which is usually found at <code>/usr/share/mobile-broadband-provider-info/serviceproviders.xml</code> on Debian/Ubuntu Linux systems.</p>

<pre>
 d = xml.parse <span class="string">[[
 &lt;serviceproviders format="2.0"&gt;
 &lt;country code="za"&gt;
     &lt;provider&gt;
         &lt;name&gt;Cell-c&lt;/name&gt;
         &lt;gsm&gt;
             &lt;network-id mcc="655" mnc="07"/&gt;
             &lt;apn value="internet"&gt;
                 &lt;username&gt;Cellcis&lt;/username&gt;
                 &lt;dns&gt;196.7.0.138&lt;/dns&gt;
                 &lt;dns&gt;196.7.142.132&lt;/dns&gt;
             &lt;/apn&gt;
         &lt;/gsm&gt;
     &lt;/provider&gt;
     &lt;provider&gt;
         &lt;name&gt;MTN&lt;/name&gt;
         &lt;gsm&gt;
             &lt;network-id mcc="655" mnc="10"/&gt;
             &lt;apn value="internet"&gt;
                 &lt;dns&gt;196.11.240.241&lt;/dns&gt;
                 &lt;dns&gt;209.212.97.1&lt;/dns&gt;
             &lt;/apn&gt;
         &lt;/gsm&gt;
     &lt;/provider&gt;
     &lt;provider&gt;
         &lt;name&gt;Vodacom&lt;/name&gt;
         &lt;gsm&gt;
             &lt;network-id mcc="655" mnc="01"/&gt;
             &lt;apn value="internet"&gt;
                 &lt;dns&gt;196.207.40.165&lt;/dns&gt;
                 &lt;dns&gt;196.43.46.190&lt;/dns&gt;
             &lt;/apn&gt;
             &lt;apn value="unrestricted"&gt;
                 &lt;name&gt;Unrestricted&lt;/name&gt;
                 &lt;dns&gt;196.207.32.69&lt;/dns&gt;
                 &lt;dns&gt;196.43.45.190&lt;/dns&gt;
             &lt;/apn&gt;
         &lt;/gsm&gt;
     &lt;/provider&gt;
     &lt;provider&gt;
         &lt;name&gt;Virgin Mobile&lt;/name&gt;
         &lt;gsm&gt;
             &lt;apn value="vdata"&gt;
                 &lt;dns&gt;196.7.0.138&lt;/dns&gt;
                 &lt;dns&gt;196.7.142.132&lt;/dns&gt;
             &lt;/apn&gt;
         &lt;/gsm&gt;
     &lt;/provider&gt;
 &lt;/country&gt;

 &lt;/serviceproviders&gt;
 ]]</span>
</pre>


<p>Getting the names of the providers per-country is straightforward:</p>

<pre>
 <span class="keyword">local</span> t = {}
 <span class="keyword">for</span> country <span class="keyword">in</span> d:childtags() <span class="keyword">do</span>
     <span class="keyword">local</span> providers = {}
     t[country.tag] = providers
     <span class="keyword">for</span> provider <span class="keyword">in</span> country:childtags() <span class="keyword">do</span>
         <span class="global">table</span>.insert(providers,provider:child_with_name(<span class="string">'name'</span>):get_text())
     <span class="keyword">end</span>
 <span class="keyword">end</span>

 pretty.dump(t)
 <span class="comment">--&gt;
</span> {
   country = {
     <span class="string">"Cell-c"</span>,
     <span class="string">"MTN"</span>,
     <span class="string">"Vodacom"</span>,
     <span class="string">"Virgin Mobile"</span>
   }
 }
</pre>


<h4>Generating XML with &lsquo;xmlification&rsquo;</h4>

<p>This feature is inspired by the <code>htmlify</code> function used by <a href="http://keplerproject.github.com/orbit/">Orbit</a> to simplify HTML generation, except that no function environment magic is used; the <code>tags</code> function returns a set of <em>constructors</em> for elements of the given tag names.</p>

<pre>
 &gt; nodes, node = xml.tags <span class="string">'nodes, node'</span>
 &gt; = node <span class="string">'alice'</span>
 &lt;node&gt;alice&lt;/node&gt;
 &gt; = nodes { node {id=<span class="string">'1'</span>,<span class="string">'alice'</span>}}
 &lt;nodes&gt;&lt;node id=<span class="string">'1'</span>&gt;alice&lt;/node&gt;&lt;/nodes&gt;
</pre>


<p>The flexibility of Lua tables is very useful here, since both the attributes and the children of an element can be encoded naturally. The argument to these tag constructors is either a single value (like a string) or a table where the attributes are the named keys and the children are the array values.</p>

<h4>Generating XML using Templates</h4>

<p>A template is a little XML document which contains dollar-variables. The <code>subst</code> method on a document is fed an array of tables containing values for these variables. Note how the parent tag name is specified:</p>

<pre>
 &gt; templ = xml.parse <span class="string">"&lt;node id='$id'&gt;$name&lt;/node&gt;"</span>
 &gt; = templ:subst {tag=<span class="string">'nodes'</span>, {id=<span class="number">1</span>,name=<span class="string">'alice'</span>},{id=<span class="number">2</span>,name=<span class="string">'john'</span>}}
 &lt;nodes&gt;&lt;node id=<span class="string">'1'</span>&gt;alice&lt;/node&gt;&lt;node id=<span class="string">'2'</span>&gt;john&lt;/node&gt;&lt;/nodes&gt;
</pre>


<h4>Extracting Data using Templates</h4>

<p>Matching goes in the opposite direction.  We have a document, and would like to extract values from it using a pattern.</p>

<p>A common use of this is parsing the XML result of API queries.  The <a href="http://blog.programmableweb.com/2010/02/08/googles-secret-weather-api/">(undocumented) Google Weather API</a> is a good example. Grabbing the result of <code>http://www.google.com/ig/api?weather=Johannesburg,ZA" we get something like this, after pretty-printing:</code></p>

<pre>
 &lt;xml_api_reply version=<span class="string">'1'</span>&gt;
   &lt;weather module_id=<span class="string">'0'</span> tab_id=<span class="string">'0'</span> mobile_zipped=<span class="string">'1'</span> section=<span class="string">'0'</span> row=<span class="string">'0'</span> mobile_row=<span class="string">'0'</span>&gt;
     &lt;forecast_information&gt;
       &lt;city data=<span class="string">'Johannesburg, Gauteng'</span>/&gt;
       &lt;postal_code data=<span class="string">'Johannesburg,ZA'</span>/&gt;
       &lt;latitude_e6 data=<span class="string">''</span>/&gt;
       &lt;longitude_e6 data=<span class="string">''</span>/&gt;
       &lt;forecast_date data=<span class="string">'2010-10-02'</span>/&gt;
       &lt;current_date_time data=<span class="string">'2010-10-02 18:30:00 +0000'</span>/&gt;
       &lt;unit_system data=<span class="string">'US'</span>/&gt;
     &lt;/forecast_information&gt;
     &lt;current_conditions&gt;
       &lt;condition data=<span class="string">'Clear'</span>/&gt;
       &lt;temp_f data=<span class="string">'75'</span>/&gt;
       &lt;temp_c data=<span class="string">'24'</span>/&gt;
       &lt;humidity data=<span class="string">'Humidity: 19%'</span>/&gt;
       &lt;icon data=<span class="string">'/ig/images/weather/sunny.gif'</span>/&gt;
       &lt;wind_condition data=<span class="string">'Wind: NW at 7 mph'</span>/&gt;
     &lt;/current_conditions&gt;
     &lt;forecast_conditions&gt;
       &lt;day_of_week data=<span class="string">'Sat'</span>/&gt;
       &lt;low data=<span class="string">'60'</span>/&gt;
       &lt;high data=<span class="string">'89'</span>/&gt;
       &lt;icon data=<span class="string">'/ig/images/weather/sunny.gif'</span>/&gt;
       &lt;condition data=<span class="string">'Clear'</span>/&gt;
     &lt;/forecast_conditions&gt;
     ....
    &lt;/weather&gt;
 &lt;/xml_api_reply&gt;
</pre>


<p>Assume that the above XML has been read into <code>google</code>. The idea is to write a pattern looking like a template, and use it to extract some values of interest:</p>

<pre>
 t = <span class="string">[[
   &lt;weather&gt;
     &lt;current_conditions&gt;
       &lt;condition data='$condition'/&gt;
       &lt;temp_c data='$temp'/&gt;
     &lt;/current_conditions&gt;
   &lt;/weather&gt;
 ]]</span>

 <span class="keyword">local</span> res, ret = google:match(t)
 pretty.dump(res)
</pre>


<p>And the output is:</p>

<pre>
 {
   condition = <span class="string">"Clear"</span>,
   temp = <span class="string">"24"</span>
 }
</pre>


<p>The <code>match</code> method can be passed a LOM document or some text, which will be parsed first. Note that <code>$NUMBER</code> is treated specially as a numerical index, so that <code>$1</code> is the first element of the resulting array, etc.</p>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
