<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Luadocs for base.lua</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h1>Modules</h1>
<ul>

	<li>
		<a href="../modules/base.html">base</a>
	</li>

	<li>
		<a href="../modules/bin.html">bin</a>
	</li>

	<li>
		<a href="../modules/debug.html">debug</a>
	</li>

	<li>
		<a href="../modules/fstable.html">fstable</a>
	</li>

	<li>
		<a href="../modules/getopt.html">getopt</a>
	</li>

	<li>
		<a href="../modules/io.html">io</a>
	</li>

	<li>
		<a href="../modules/lcs.html">lcs</a>
	</li>

	<li>
		<a href="../modules/list.html">list</a>
	</li>

	<li>
		<a href="../modules/math.html">math</a>
	</li>

	<li>
		<a href="../modules/mbox.html">mbox</a>
	</li>

	<li>
		<a href="../modules/object.html">object</a>
	</li>

	<li>
		<a href="../modules/package.html">package</a>
	</li>

	<li>
		<a href="../modules/parser.html">parser</a>
	</li>

	<li>
		<a href="../modules/set.html">set</a>
	</li>

	<li>
		<a href="../modules/std.html">std</a>
	</li>

	<li>
		<a href="../modules/strbuf.html">strbuf</a>
	</li>

	<li>
		<a href="../modules/string.html">string</a>
	</li>

	<li>
		<a href="../modules/table.html">table</a>
	</li>

	<li>
		<a href="../modules/tree.html">tree</a>
	</li>

</ul>



<!-- File list -->

<h1>Files</h1>
<ul>

	<li><strong>base.lua</strong></li>
	
	<li>
		<a href="../files/bin.html">bin.lua</a>
	</li>

	<li>
		<a href="../files/debug_ext.html">debug_ext.lua</a>
	</li>

	<li>
		<a href="../files/debug_init.html">debug_init.lua</a>
	</li>

	<li>
		<a href="../files/fstable.html">fstable.lua</a>
	</li>

	<li>
		<a href="../files/getopt.html">getopt.lua</a>
	</li>

	<li>
		<a href="../files/io_ext.html">io_ext.lua</a>
	</li>

	<li>
		<a href="../files/lcs.html">lcs.lua</a>
	</li>

	<li>
		<a href="../files/list.html">list.lua</a>
	</li>

	<li>
		<a href="../files/math_ext.html">math_ext.lua</a>
	</li>

	<li>
		<a href="../files/mbox.html">mbox.lua</a>
	</li>

	<li>
		<a href="../files/modules.html">modules.lua</a>
	</li>

	<li>
		<a href="../files/object.html">object.lua</a>
	</li>

	<li>
		<a href="../files/package_ext.html">package_ext.lua</a>
	</li>

	<li>
		<a href="../files/parser.html">parser.lua</a>
	</li>

	<li>
		<a href="../files/set.html">set.lua</a>
	</li>

	<li>
		<a href="../files/std.html">std.lua</a>
	</li>

	<li>
		<a href="../files/strbuf.html">strbuf.lua</a>
	</li>

	<li>
		<a href="../files/strict.html">strict.lua</a>
	</li>

	<li>
		<a href="../files/string_ext.html">string_ext.lua</a>
	</li>

	<li>
		<a href="../files/table_ext.html">table_ext.lua</a>
	</li>

	<li>
		<a href="../files/tree.html">tree.lua</a>
	</li>

	<li>
		<a href="../files/xml.html">xml.lua</a>
	</li>

</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File <code>base.lua</code></h1>


<p>Adds to the existing global functions</p>






<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#_G.assert">_G.assert</a>&nbsp;(v, f, ...)</td>
	<td class="summary">Extend to allow formatted arguments.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.bind">_G.bind</a>&nbsp;(f, ...)</td>
	<td class="summary">Partially apply a function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.collect">_G.collect</a>&nbsp;(i, ...)</td>
	<td class="summary">Collect the results of an iterator.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.compose">_G.compose</a>&nbsp;(..., f1...fn)</td>
	<td class="summary">Compose functions.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.curry">_G.curry</a>&nbsp;(f, n)</td>
	<td class="summary">Curry a function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.die">_G.die</a>&nbsp;(...)</td>
	<td class="summary">Die with error.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.eval">_G.eval</a>&nbsp;(s)</td>
	<td class="summary">Evaluate a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.filter">_G.filter</a>&nbsp;(p, i, ...)</td>
	<td class="summary">Filter an iterator with a predicate.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.fold">_G.fold</a>&nbsp;(f, d, i, ...)</td>
	<td class="summary">Fold a binary function into an iterator.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.id">_G.id</a>&nbsp;(...)</td>
	<td class="summary">Identity function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.map">_G.map</a>&nbsp;(f, i, ...)</td>
	<td class="summary">Map a function over an iterator.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.metamethod">_G.metamethod</a>&nbsp;(x, n)</td>
	<td class="summary">Return given metamethod, if any, or nil.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.nodes">_G.nodes</a>&nbsp;(tr)</td>
	<td class="summary">Tree iterator.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.pack">_G.pack</a>&nbsp;(...)</td>
	<td class="summary">Turn a tuple into a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.pickle">_G.pickle</a>&nbsp;(x)</td>
	<td class="summary">Convert a value to a string.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.prettytostring">_G.prettytostring</a>&nbsp;(t, indent, spacing)</td>
	<td class="summary">Pretty-print a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.render">_G.render</a>&nbsp;(x, open, close, elem, pair, sep, roots)</td>
	<td class="summary">Turn tables into strings with recursion detection.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.ripairs">_G.ripairs</a>&nbsp;(t)</td>
	<td class="summary">An iterator like ipairs, but in reverse.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.tostring">_G.tostring</a>&nbsp;(x)</td>
	<td class="summary">Extend <code>tostring</code> to work better on tables.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.totable">_G.totable</a>&nbsp;(x)</td>
	<td class="summary">Turn an object into a table according to __totable metamethod.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#_G.warn">_G.warn</a>&nbsp;(...)</td>
	<td class="summary">Give warning with the name of program and file (if any).</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#render_CloseRenderer">render_CloseRenderer</a>&nbsp;(t)</td>
	<td class="summary"> </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#render_ElementRenderer">render_ElementRenderer</a>&nbsp;(e)</td>
	<td class="summary"> </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#render_OpenRenderer">render_OpenRenderer</a>&nbsp;(t)</td>
	<td class="summary"> </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#render_PairRenderer N.B. the function should not try to render i and v, or treat them recursively.">render_PairRenderer N.B. the function should not try to render i and v, or treat them recursively.</a>&nbsp;(t, i, v, is, vs)</td>
	<td class="summary"> </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#render_SeparatorRenderer">render_SeparatorRenderer</a>&nbsp;(t, i, v, j, w)</td>
	<td class="summary"> </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tree_Iterator">tree_Iterator</a>&nbsp;(n, p)</td>
	<td class="summary"> </td>
	</tr>

</table>




<h2>Tables</h2>
<table class="table_list">

	<tr>
	<td class="name" nowrap><a href="#_G.op">_G.op</a></td>
	<td class="summary">Functional forms of infix operators.</td>
	</tr>

</table>



<br/>
<br/>




<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="_G.assert"></a><strong>_G.assert</strong>&nbsp;(v, f, ...)</dt>
<dd>
Extend to allow formatted arguments.


<h3>Parameters</h3>
<ul>
	
	<li>
	  v: value to assert
	</li>
	
	<li>
	  f: format
	</li>
	
	<li>
	  ...: arguments to format
	</li>
	
</ul>






<h3>Return value:</h3>
value



</dd>




<dt><a name="_G.bind"></a><strong>_G.bind</strong>&nbsp;(f, ...)</dt>
<dd>
Partially apply a function.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function to apply partially
	</li>
	
	<li>
	  ...: arguments to bind
	</li>
	
</ul>






<h3>Return value:</h3>
function with ai already bound



</dd>




<dt><a name="_G.collect"></a><strong>_G.collect</strong>&nbsp;(i, ...)</dt>
<dd>
Collect the results of an iterator.


<h3>Parameters</h3>
<ul>
	
	<li>
	  i: iterator
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>






<h3>Return value:</h3>
results of running the iterator on its arguments



</dd>




<dt><a name="_G.compose"></a><strong>_G.compose</strong>&nbsp;(..., f1...fn)</dt>
<dd>
Compose functions.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: 
	</li>
	
	<li>
	  f1...fn: functions to compose
	</li>
	
</ul>






<h3>Return value:</h3>
composition of f1 ... fn



</dd>




<dt><a name="_G.curry"></a><strong>_G.curry</strong>&nbsp;(f, n)</dt>
<dd>
Curry a function.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function to curry
	</li>
	
	<li>
	  n: number of arguments
	</li>
	
</ul>






<h3>Return value:</h3>
curried version of f



</dd>




<dt><a name="_G.die"></a><strong>_G.die</strong>&nbsp;(...)</dt>
<dd>
Die with error.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: arguments for format
	</li>
	
</ul>








</dd>




<dt><a name="_G.eval"></a><strong>_G.eval</strong>&nbsp;(s)</dt>
<dd>
Evaluate a string.


<h3>Parameters</h3>
<ul>
	
	<li>
	  s: string
	</li>
	
</ul>






<h3>Return value:</h3>
value of string



</dd>




<dt><a name="_G.filter"></a><strong>_G.filter</strong>&nbsp;(p, i, ...)</dt>
<dd>
Filter an iterator with a predicate.


<h3>Parameters</h3>
<ul>
	
	<li>
	  p: predicate
	</li>
	
	<li>
	  i: iterator
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>






<h3>Return value:</h3>
result table containing elements e for which p (e)



</dd>




<dt><a name="_G.fold"></a><strong>_G.fold</strong>&nbsp;(f, d, i, ...)</dt>
<dd>
Fold a binary function into an iterator.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  d: initial first argument
	</li>
	
	<li>
	  i: iterator
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>






<h3>Return value:</h3>
result



</dd>




<dt><a name="_G.id"></a><strong>_G.id</strong>&nbsp;(...)</dt>
<dd>
Identity function.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: 
	</li>
	
</ul>






<h3>Return value:</h3>
the arguments passed to the function



</dd>




<dt><a name="_G.map"></a><strong>_G.map</strong>&nbsp;(f, i, ...)</dt>
<dd>
Map a function over an iterator.


<h3>Parameters</h3>
<ul>
	
	<li>
	  f: function
	</li>
	
	<li>
	  i: iterator
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>






<h3>Return value:</h3>
result table



</dd>




<dt><a name="_G.metamethod"></a><strong>_G.metamethod</strong>&nbsp;(x, n)</dt>
<dd>
Return given metamethod, if any, or nil.


<h3>Parameters</h3>
<ul>
	
	<li>
	  x: object to get metamethod of
	</li>
	
	<li>
	  n: name of metamethod to get
	</li>
	
</ul>






<h3>Return value:</h3>
metamethod function or nil if no metamethod or not a function



</dd>




<dt><a name="_G.nodes"></a><strong>_G.nodes</strong>&nbsp;(tr)</dt>
<dd>
Tree iterator.


<h3>Parameters</h3>
<ul>
	
	<li>
	  tr: tree to iterate over
	</li>
	
</ul>






<h3>Return value:</h3>
iterator function



<h3>See also:</h3>
<ul>
	
	<li><a href="../files/base.html#tree_Iterator">
		tree_Iterator
	</a>
	
</ul>

</dd>




<dt><a name="_G.pack"></a><strong>_G.pack</strong>&nbsp;(...)</dt>
<dd>
Turn a tuple into a list.


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: tuple
	</li>
	
</ul>






<h3>Return value:</h3>
list



</dd>




<dt><a name="_G.pickle"></a><strong>_G.pickle</strong>&nbsp;(x)</dt>
<dd>
Convert a value to a string. The string can be passed to dostring to retrieve the value. <br>TODO: Make it work for recursive tables.


<h3>Parameters</h3>
<ul>
	
	<li>
	  x: object to pickle
	</li>
	
</ul>






<h3>Return value:</h3>
string such that eval (s) is the same value as x



</dd>




<dt><a name="_G.prettytostring"></a><strong>_G.prettytostring</strong>&nbsp;(t, indent, spacing)</dt>
<dd>
Pretty-print a table.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table to print
	</li>
	
	<li>
	  indent: indent between levels ["\t"]
	</li>
	
	<li>
	  spacing: space before every line
	</li>
	
</ul>






<h3>Return value:</h3>
pretty-printed string



</dd>




<dt><a name="_G.render"></a><strong>_G.render</strong>&nbsp;(x, open, close, elem, pair, sep, roots)</dt>
<dd>
Turn tables into strings with recursion detection. N.B. Functions calling render should not recurse, or recursion detection will not work.


<h3>Parameters</h3>
<ul>
	
	<li>
	  x: object to convert to string
	</li>
	
	<li>
	  open: open table renderer
	</li>
	
	<li>
	  close: close table renderer
	</li>
	
	<li>
	  elem: element renderer
	</li>
	
	<li>
	  pair: pair renderer
	</li>
	
	<li>
	  sep: separator renderer
	</li>
	
	<li>
	  roots: 
	</li>
	
</ul>






<h3>Return value:</h3>
string representation



<h3>See also:</h3>
<ul>
	
	<li><a href="../files/base.html#render_OpenRenderer">
		render_OpenRenderer
	</a>
	
	<li><a href="../files/base.html#render_CloseRenderer">
		render_CloseRenderer
	</a>
	
	<li><a href="../files/base.html#render_ElementRenderer">
		render_ElementRenderer
	</a>
	
	<li><a href="">
		render_PairRenderer
	</a>
	
	<li><a href="../files/base.html#render_SeparatorRenderer">
		render_SeparatorRenderer
	</a>
	
</ul>

</dd>




<dt><a name="_G.ripairs"></a><strong>_G.ripairs</strong>&nbsp;(t)</dt>
<dd>
An iterator like ipairs, but in reverse.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table to iterate over
	</li>
	
</ul>






<h3>Return values:</h3>
<ol>
	
	<li>iterator function
	
	<li>the table, as above
	
	<li>#t + 1
	
</ol>



</dd>




<dt><a name="_G.tostring"></a><strong>_G.tostring</strong>&nbsp;(x)</dt>
<dd>
Extend <code>tostring</code> to work better on tables.


<h3>Parameters</h3>
<ul>
	
	<li>
	  x: object to convert to string
	</li>
	
</ul>






<h3>Return value:</h3>
string representation



</dd>




<dt><a name="_G.totable"></a><strong>_G.totable</strong>&nbsp;(x)</dt>
<dd>
Turn an object into a table according to __totable metamethod.


<h3>Parameters</h3>
<ul>
	
	<li>
	  x: object to turn into a table
	</li>
	
</ul>






<h3>Return value:</h3>
table or nil



</dd>




<dt><a name="_G.warn"></a><strong>_G.warn</strong>&nbsp;(...)</dt>
<dd>
Give warning with the name of program and file (if any).


<h3>Parameters</h3>
<ul>
	
	<li>
	  ...: arguments for format
	</li>
	
</ul>








</dd>




<dt><a name="render_CloseRenderer"></a><strong>render_CloseRenderer</strong>&nbsp;(t)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table
	</li>
	
</ul>






<h3>Return value:</h3>
close table string



</dd>




<dt><a name="render_ElementRenderer"></a><strong>render_ElementRenderer</strong>&nbsp;(e)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  e: element
	</li>
	
</ul>






<h3>Return value:</h3>
element string



</dd>




<dt><a name="render_OpenRenderer"></a><strong>render_OpenRenderer</strong>&nbsp;(t)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table
	</li>
	
</ul>






<h3>Return value:</h3>
open table string



</dd>




<dt><a name="render_PairRenderer N.B. the function should not try to render i and v, or treat them recursively."></a><strong>render_PairRenderer N.B. the function should not try to render i and v, or treat them recursively.</strong>&nbsp;(t, i, v, is, vs)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table
	</li>
	
	<li>
	  i: index
	</li>
	
	<li>
	  v: value
	</li>
	
	<li>
	  is: index string
	</li>
	
	<li>
	  vs: value string
	</li>
	
</ul>






<h3>Return value:</h3>
element string



</dd>




<dt><a name="render_SeparatorRenderer"></a><strong>render_SeparatorRenderer</strong>&nbsp;(t, i, v, j, w)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  t: table
	</li>
	
	<li>
	  i: preceding index (nil on first call)
	</li>
	
	<li>
	  v: preceding value (nil on first call)
	</li>
	
	<li>
	  j: following index (nil on last call)
	</li>
	
	<li>
	  w: following value (nil on last call)
	</li>
	
</ul>






<h3>Return value:</h3>
separator string



</dd>




<dt><a name="tree_Iterator"></a><strong>tree_Iterator</strong>&nbsp;(n, p)</dt>
<dd>



<h3>Parameters</h3>
<ul>
	
	<li>
	  n: current node
	</li>
	
	<li>
	  p: path to node within the tree
	</li>
	
</ul>






<h3>Return values:</h3>
<ol>
	
	<li>type ("leaf", "branch" (pre-order) or "join" (post-order))
	
	<li>path to node ({i1...ik})
	
	<li>node
	
</ol>



</dd>


</dl>




<h2><a name="tables"></a>Tables</h2>
<dl class="table">

<dt><a name="_G.op"></a><strong>_G.op</strong></dt>
<dd>Functional forms of infix operators. Defined here so that other modules can write to it.



</dd>


</dl>




</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
